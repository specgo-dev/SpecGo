{# SPDX-License-Identifier: Apache-2.0 #}
{# Copyright (c) 2026 Ce Xu (Dylan) #}
/* Generated by SpecGo. DO NOT EDIT. */
#include "{{ header_filename }}"

#include <string.h>

static uint8_t specgo_get_bit(const uint8_t *payload, size_t bit_index) {
    const size_t byte_index = bit_index / 8U;
    const size_t bit_in_byte = bit_index % 8U;
    return (uint8_t)((payload[byte_index] >> bit_in_byte) & 0x1U);
}

static void specgo_set_bit(uint8_t *payload, size_t bit_index, uint8_t bit) {
    const size_t byte_index = bit_index / 8U;
    const size_t bit_in_byte = bit_index % 8U;
    const uint8_t mask = (uint8_t)(1U << bit_in_byte);
    if (bit != 0U) {
        payload[byte_index] = (uint8_t)(payload[byte_index] | mask);
    } else {
        payload[byte_index] = (uint8_t)(payload[byte_index] & (uint8_t)(~mask));
    }
}

static uint64_t specgo_extract_raw(const uint8_t *payload, const uint16_t *bit_positions, size_t bit_length) {
    uint64_t raw = 0ULL;
    for (size_t i = 0; i < bit_length; ++i) {
        raw |= ((uint64_t)specgo_get_bit(payload, bit_positions[i]) << i);
    }
    return raw;
}

static void specgo_insert_raw(uint8_t *payload, const uint16_t *bit_positions, size_t bit_length, uint64_t raw) {
    for (size_t i = 0; i < bit_length; ++i) {
        specgo_set_bit(payload, bit_positions[i], (uint8_t)((raw >> i) & 0x1ULL));
    }
}

{% if has_signed_signals %}
static int64_t specgo_sign_extend_u64(uint64_t raw, size_t bit_length) {
    if (bit_length == 0U || bit_length >= 64U) {
        return (int64_t)raw;
    }
    {
        const uint64_t sign_bit = (1ULL << (bit_length - 1U));
        if ((raw & sign_bit) == 0ULL) {
            return (int64_t)raw;
        }
    }
    return (int64_t)(raw | (~((1ULL << bit_length) - 1ULL)));
}
{% endif %}

{% for msg in messages %}
int {{ msg.encode_fn }}(uint8_t *out_payload, size_t out_size, const {{ msg.struct_name }} *in) {
    if (out_payload == NULL || in == NULL) {
        return SPECGO_ERR_NULL;
    }
    if (out_size < {{ msg.dlc_macro }}) {
        return SPECGO_ERR_SIZE;
    }

    memset(out_payload, 0, {{ msg.dlc_macro }});
{% for sig in msg.signals %}
{% if sig.signed %}
    if (in->{{ sig.c_name }} < {{ sig.range_min_c }} || in->{{ sig.c_name }} > {{ sig.range_max_c }}) {
        return SPECGO_ERR_RANGE;
    }
    {
        const uint16_t bit_positions[{{ sig.bit_length }}] = { {{ sig.bit_positions_c }} };
        uint64_t raw = (uint64_t)in->{{ sig.c_name }};
{% if sig.bit_length < 64 %}
        raw &= {{ sig.bit_mask_c }};
{% endif %}
        specgo_insert_raw(out_payload, bit_positions, {{ sig.bit_length }}U, raw);
    }
{% else %}
    if (in->{{ sig.c_name }} > {{ sig.range_max_c }}) {
        return SPECGO_ERR_RANGE;
    }
    {
        const uint16_t bit_positions[{{ sig.bit_length }}] = { {{ sig.bit_positions_c }} };
        specgo_insert_raw(out_payload, bit_positions, {{ sig.bit_length }}U, in->{{ sig.c_name }});
    }
{% endif %}
{% endfor %}
    return SPECGO_OK;
}

int {{ msg.decode_fn }}(const uint8_t *payload, size_t payload_size, {{ msg.struct_name }} *out) {
    if (payload == NULL || out == NULL) {
        return SPECGO_ERR_NULL;
    }
    if (payload_size < {{ msg.dlc_macro }}) {
        return SPECGO_ERR_SIZE;
    }

    memset(out, 0, sizeof(*out));
{% for sig in msg.signals %}
{% if sig.signed %}
    {
        const uint16_t bit_positions[{{ sig.bit_length }}] = { {{ sig.bit_positions_c }} };
        const uint64_t raw = specgo_extract_raw(payload, bit_positions, {{ sig.bit_length }}U);
        out->{{ sig.c_name }} = specgo_sign_extend_u64(raw, {{ sig.bit_length }}U);
    }
{% else %}
    {
        const uint16_t bit_positions[{{ sig.bit_length }}] = { {{ sig.bit_positions_c }} };
        out->{{ sig.c_name }} = specgo_extract_raw(payload, bit_positions, {{ sig.bit_length }}U);
    }
{% endif %}
{% endfor %}
    return SPECGO_OK;
}

{% endfor %}
